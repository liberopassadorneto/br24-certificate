{"version":3,"file":"archiver.js","sourceRoot":"","sources":["../../../src/public/node/archiver.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,YAAY,EAAC,MAAM,WAAW,CAAA;AACtC,OAAO,EAAC,IAAI,EAAC,MAAM,SAAS,CAAA;AAC5B,OAAO,EAAC,WAAW,EAAE,aAAa,EAAE,WAAW,EAAC,MAAM,6BAA6B,CAAA;AACnF,OAAO,QAAQ,MAAM,UAAU,CAAA;AAC/B,OAAO,EAAC,iBAAiB,EAAC,MAAM,IAAI,CAAA;AACpC;;;;;;;GAOG;AACH,MAAM,CAAC,KAAK,UAAU,GAAG,CAAC,cAAsB,EAAE,aAAqB;IACrE,WAAW,CAAC,aAAa,CAAA,WAAW,WAAW,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,WAAW,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE,CAAC,CAAA;IAC/G,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,MAAM,EAAE,EAAC,GAAG,EAAE,cAAc,EAAE,QAAQ,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,mBAAmB,EAAE,KAAK,EAAC,CAAC,CAAA;IACnH,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACrC,MAAM,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAA;QAC/B,MAAM,MAAM,GAAG,iBAAiB,CAAC,aAAa,CAAC,CAAA;QAE/C,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE;YACjB,OAAO,EAAE,CAAA;QACX,CAAC,CAAC,CAAA;QACF,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,UAAU,KAAK;YACjC,MAAM,CAAC,KAAK,CAAC,CAAA;QACf,CAAC,CAAC,CAAA;QACF,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;QAEpB,KAAK,MAAM,QAAQ,IAAI,UAAU,EAAE;YACjC,MAAM,gBAAgB,GAAG,YAAY,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAA;YAC/D,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,EAAC,IAAI,EAAE,gBAAgB,EAAC,CAAC,CAAA;SACjD;QAED,mEAAmE;QACnE,OAAO,CAAC,QAAQ,EAAE,CAAA;IACpB,CAAC,CAAC,CAAA;AACJ,CAAC","sourcesContent":["import {relativePath} from './path.js'\nimport {glob} from './fs.js'\nimport {outputDebug, outputContent, outputToken} from '../../public/node/output.js'\nimport archiver from 'archiver'\nimport {createWriteStream} from 'fs'\n/**\n * It zips a directory normalizing the paths to be forward-slash. Note that unzipping\n * the zip generated by this function from a Windows environment won't work because paths\n * need to be made backward-slash.\n *\n * @param inputDirectory - The absolute path to the directory to be zipped.\n * @param outputZipPath - The absolute path to the output zip file.\n */\nexport async function zip(inputDirectory: string, outputZipPath: string): Promise<void> {\n  outputDebug(outputContent`Zipping ${outputToken.path(inputDirectory)} into ${outputToken.path(outputZipPath)}`)\n  const pathsToZip = await glob('**/*', {cwd: inputDirectory, absolute: true, dot: true, followSymbolicLinks: false})\n  return new Promise((resolve, reject) => {\n    const archive = archiver('zip')\n    const output = createWriteStream(outputZipPath)\n\n    output.on('close', function () {\n      resolve()\n    })\n    archive.on('error', function (error) {\n      reject(error)\n    })\n    archive.pipe(output)\n\n    for (const filePath of pathsToZip) {\n      const fileRelativePath = relativePath(inputDirectory, filePath)\n      archive.file(filePath, {name: fileRelativePath})\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    archive.finalize()\n  })\n}\n"]}